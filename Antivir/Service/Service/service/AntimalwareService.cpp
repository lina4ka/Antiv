#include "AntimalwareService.h"



namespace Antimalware::ServiceApp
{
	int AntimalwareService::Init()
	{
		
		if (!std::filesystem::exists(std::filesystem::current_path().string()+ "\\ANTIV_memoryFolder"))
			std::filesystem::create_directory(std::filesystem::current_path().string() + "\\ANTIV_memoryFolder");
		if (!std::filesystem::exists(std::filesystem::current_path().string() + "\\ANTIV_quarFolder"))
			std::filesystem::create_directory(std::filesystem::current_path().string() + "\\ANTIV_quarFolder");
		storage.reset(new infoStorage());
		malwareData.reset(new MalwareData("C:\\Windows\\ANTIV_memoryFolder\\data.bin", "Sirotkina"));
		if (!malwareData->isCorrect())
			return 2;
		malwareData->readData();
		scanner.reset(new Scanner(malwareData));		
		schedule.reset(new Schedule(scanner));
		monitor.reset(new Monitoring(scanner));
		return 0;
	}

	std::pair<HANDLE, HANDLE> AntimalwareService::waitConnection()
	{
		HANDLE pipeBack = CreateNamedPipe(
			L"\\\\.\\pipe\\AntimalwarePipeBack",
			PIPE_ACCESS_DUPLEX,
			PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
			PIPE_UNLIMITED_INSTANCES,
			4096, 4096, 5000, NULL);
		ConnectNamedPipe(pipeBack, NULL);
		HANDLE pipe = CreateNamedPipe(
			L"\\\\.\\pipe\\AntimalwarePipe",
			PIPE_ACCESS_DUPLEX,
			PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
			PIPE_UNLIMITED_INSTANCES,
			4096, 4096, 5000, NULL);
		ConnectNamedPipe(pipe, NULL);		
		backList.push_back(pipeBack);
		frontList.push_back(pipe);
		return std::make_pair(pipe,pipeBack);
	}

	void AntimalwareService::work(std::pair<HANDLE, HANDLE> pipes)
	{
		Sender fromClient(pipes.first);
		Sender toClient(pipes.second);
		msg Message;
		sendInitial(toClient);
		while (true)
		{
			if (!fromClient.getFrom(Message))
				break;
			//toDO(toClient, Message);
			std::thread th(&AntimalwareService::toDO, this, toClient, Message);
			th.detach();
		}
		toClient.changeHandle(NULL);
		FlushFileBuffers(pipes.first);
		DisconnectNamedPipe(pipes.first);
		CloseHandle(pipes.first);
		fromClient.changeHandle(NULL);
		FlushFileBuffers(pipes.second);
		DisconnectNamedPipe(pipes.second);
		CloseHandle(pipes.second);
	}

	void AntimalwareService::toDO(Sender answer, msg Message)
	{
		switch (Message.command)
		{
		case COMMANDLIST::UNKNOWN:
			break;
		case COMMANDLIST::START_SCAN:
		{
			auto objVec = scanner->createObject(Message.stringArray);
			answer.sendTo(COMMANDLIST::START_SCAN, objVec.size());
			int countOfMalvare = 0;
			int res = 0;
			for (auto & el : objVec)
			{
				if (scanner->isStop())
					break;
				res = scanner->scan(el);
				answer.sendTo(COMMANDLIST::GET_REPORT, res, el.path.string());
				if (res == 1)
				{
					++countOfMalvare;
					storage->addDetected(el.path);
				}
			}
			if (!scanner->isStop())
				answer.sendTo(COMMANDLIST::START_SCAN, vector<uint64_t>{objVec.size(),(uint64_t)countOfMalvare,objVec.size()-countOfMalvare});
			scanner->start();
			Message.command = COMMANDLIST::UPDATE_INFO;
			toDO(answer, Message);
			break;
		}
		case COMMANDLIST::STOP_SCAN:
			scanner->stop();
			answer.sendTo(COMMANDLIST::STOP_SCAN,"Сканирование остановленно");
			break;
		case COMMANDLIST::MOVE_TO_QUARANTINE:
			for (auto const& el : Message.numericArray)
				storage->transfer(el);
			Message.command = COMMANDLIST::UPDATE_INFO;
			toDO(answer, Message);
			break;
		case COMMANDLIST::RETURN_FROM_QUARANTINE:
			for (auto const& el : Message.numericArray)
				storage->transfer(el,false);
			Message.command = COMMANDLIST::UPDATE_INFO;
			toDO(answer, Message);
			break;
		case COMMANDLIST::DELETE_FILE:
			for (auto const& el : Message.numericArray)
				storage->removeFile(el);
			Message.command = COMMANDLIST::UPDATE_INFO;
			toDO(answer, Message);
			break;
		case COMMANDLIST::START_MONITOR:
			for (auto &el : Message.stringArray)
				monitor->addMonitoring(el);
			answer.sendTo(COMMANDLIST::START_MONITOR, monitor->getList());
			break;
		case COMMANDLIST::END_MONITOR:
		{
			for (auto& el : Message.numericArray)
			{
				monitor->delMonitoring(el);
				answer.sendTo(COMMANDLIST::END_MONITOR, el);
			}
			break;
		}
		case COMMANDLIST::START_SCHEDULE:
			for (size_t index = 0; index < Message.stringArray.size(); ++index)
			{
				schedule->addSchedule(Message.stringArray.at(index), Message.numericArray.at(index));
				answer.sendTo(COMMANDLIST::START_SCHEDULE, Message.numericArray.at(index), Message.stringArray.at(index));
			}
			break;
		case COMMANDLIST::STOP_SCHEDULE:
		{
			uint64_t index = 0;
			for (size_t index = 0; index < Message.stringArray.size(); ++index)
			{
				schedule->removeSchedule(Message.stringArray.at(index), Message.numericArray.at(index));
				answer.sendTo(COMMANDLIST::STOP_SCHEDULE, Message.numericArray.at(index), Message.stringArray.at(index));
			}
			break;
		}
		case COMMANDLIST::UPDATE_INFO:
			answer.sendTo(COMMANDLIST::UPDATE_INFO, storage->getInnerInfo());
			break;
		case COMMANDLIST::OFF:
			DoStop();
			ExitProcess(0);
			break;
		default:
			break;
		}
	}

	void AntimalwareService::monitorBackGround()
	{
		Sender send(NULL);
		while (true)
		{
			this_thread::sleep_for(std::chrono::seconds(10));
			if (!monitor)
				return;
			auto result = monitor->result();
			if (!result.empty())
			{
				for (auto& el : result)
					storage->addDetected(el);
				for (auto& el : backList)
				{
					if (el != NULL || el != INVALID_HANDLE_VALUE)
					{
						send.changeHandle(el);
						send.sendTo(COMMANDLIST::UPDATE_INFO, storage->getInnerInfo());

					}
				}
			}
		}
	}

	void AntimalwareService::scheduleBackGround()
	{
		Sender send(NULL);
		while (true)
		{
			this_thread::sleep_for(std::chrono::seconds(10));
			if (!schedule)
				return;
			auto result = schedule->getReult();
			if (!result.empty())
			{
				for (auto& el : result)
					for (auto& _el : el.resPath)
					storage->addDetected(_el);

				for (auto& el : backList)
				{
					if (el != NULL || el != INVALID_HANDLE_VALUE)
					{
						send.changeHandle(el);
						send.sendTo(COMMANDLIST::UPDATE_INFO, storage->getInnerInfo());
						for (auto& _el : result)
							send.sendTo(COMMANDLIST::STOP_SCHEDULE, _el.time, _el.path.string());

					}
				}
			}
		}
		

	}
	void AntimalwareService::sendInitial(Sender answer)
	{
		answer.sendTo(COMMANDLIST::UPDATE_INFO, storage->getInnerInfo());
		answer.sendTo(COMMANDLIST::START_MONITOR, monitor->getList());
		auto res = schedule->getActive();
		for (auto&el : res)
			answer.sendTo(COMMANDLIST::START_SCHEDULE, el.time, el.path.string());
	}


	void AntimalwareService::DoWork()
	{
		auto con = waitConnection();
		std::thread th1(&AntimalwareService::work,this,con);
		th1.detach();
		std::this_thread::sleep_for(std::chrono::microseconds(100));
		if (onlyOnce)
		{
			onlyOnce = !onlyOnce;
			thread t2(&AntimalwareService::scheduleBackGround, this);
			t2.detach();
			thread t3(&AntimalwareService::monitorBackGround, this);
			t3.detach();
		}
	}

	int AntimalwareService::DoStop()
	{
		storage->save();
		schedule->save();
		monitor->save();
		for (auto& el : backList)
		{
			FlushFileBuffers(el);
			DisconnectNamedPipe(el);
			CloseHandle(el);
		}
		for (auto& el : frontList)
		{
			FlushFileBuffers(el);
			DisconnectNamedPipe(el);
			CloseHandle(el);
		}
		return 0;
	}

	AntimalwareServiceFactory::AntimalwareServiceFactory()
	{
	}

	std::unique_ptr<ServiceLib::ServiceManagement::Service> AntimalwareServiceFactory::Create()
	{
		return std::make_unique<AntimalwareService>();
	}

}